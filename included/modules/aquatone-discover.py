#!/usr/bin/python

from included.ModuleTemplate import ToolTemplate
from database.repositories import BaseDomainRepository, DomainRepository
import os
import json

class Module(ToolTemplate):

    name = "aquatone-discover"
    binary_name = "aquatone-discover"

    def __init__(self, db):
        self.db = db
        self.Domain = DomainRepository(db, self.name)
        self.BaseDomain = BaseDomainRepository(db, self.name)


    def set_options(self):
        super(Module, self).set_options()

        self.options.add_argument('-p', '--print_message', help="Message to print")
        self.options.add_argument('-d','--domain', help="Target domain for aquatone")
        self.options.add_argument('-f', '--file', help="Import domains from file")
#        self.options.add_argument('-t','--threads', help="Number of threads to use, defaults=30", default="30")
        self.options.add_argument('--wordlist', help="Wordlist/Dictionary to use for brute-forcing (optional)")        
        self.options.add_argument('-i', '--import_database', help="Import domains from database", action="store_true")

    def get_targets(self, args):
        '''
        This module is used to build out a target list and output file list, depending on the arguments. Should return a
        list in the format [(target, output), (target, output), etc, etc]
        '''
        targets = []

#this might prevent the armory timeout?
	args.timeout = 0

        if args.domain:
        	created, domain = self.BaseDomain.find_or_create(domain=args.domain)
        	targets.append(domain.domain)

        elif args.file:
        	domainsFile = open(args.file).read().split('\n')
        	for d in domainsFile:
        		if d:
        	 		created, domain = self.BaseDomain.find_or_create(domain=args.domain)
        	 		targets.append(domain.domain)

        elif args.import_database:
            all_domains = self.BaseDomain.all(tool=self.name, scope_type="passive")
            for d in all_domains:
                targets.append(d.domain)
        else:
            print("You need to supply domain(s).")

	output_path= ""
	res = []
	for t in targets:
		res.append((t, output_path))

        return res

    def build_cmd(self, args):
        '''
        Create the actual command that will be executed. Use {target} and {output} as placeholders.
        '''
        cmd = self.binary + " -d {target} {output}"
        print "All aquatone results are stored in /root/aquatone/<domainname>"

        if args.extra_args:
        	cmd += args.extra_args

        return cmd


    def process_output(self, cmds):
        '''
        Process the output generated by the earlier commands.
        '''
        for cmd in cmds:
        	output_path = os.path.join("/root/aquatone/",cmd[0]+"/hosts.json")

		data2= json.loads(open(output_path).read())

		for sub, ip in data2.iteritems():
			created = False
			new_domain = sub.lower().replace("www.","")

			if new_domain:
				created, subdomain = self.Domain.find_or_create(domain=new_domain)
		
		
	self.Domain.commit()
#        	data = open(output_path).read().split('\n')
#            	for d in data:
#                	new_domain = d.split(':')[0].lower()
#                	if new_domain:
#                    		created, subdomain = self.Domain.find_or_create(domain=new_domain)


	self.Domain.commit()
